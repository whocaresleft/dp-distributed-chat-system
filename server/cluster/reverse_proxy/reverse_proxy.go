package reverseproxy

import (
	"context"
	"fmt"
	"log"
	"net"
	"os"
	"server/cluster/reverse_proxy/protocol"
	"sync"

	"google.golang.org/grpc"
)

type proxyEntry struct {
	conn *grpc.ClientConn
}

type ReverseProxy struct {
	protocol.UnimplementedEntryRegistryServer

	inputNodes map[string]*proxyEntry // it uses the struct generated by proto
	loggers    map[string]*log.Logger

	entryLock sync.RWMutex
	logLock   sync.RWMutex
}

func (r *ReverseProxy) logf(node, format string, v ...any) {
	r.logLock.Lock()
	if logger, ok := r.loggers[node]; ok {
		logger.Printf(format, v...)
	}
	r.logLock.Unlock()
}

func (r *ReverseProxy) addLog(node string) error {
	r.logLock.Lock()
	defer r.logLock.Unlock()
	file, err := os.OpenFile(fmt.Sprintf("%s.log", node), os.O_CREATE|os.O_APPEND|os.O_WRONLY|os.O_TRUNC, 0755)
	if err != nil {
		return err
	}
	r.loggers[node] = log.New(file, fmt.Sprintf("[%s]", node), log.Ldate|log.Ltime)
	return nil
}

func NewReverseProxy() *ReverseProxy {

	file, _ := os.OpenFile("main.log", os.O_CREATE|os.O_APPEND|os.O_WRONLY|os.O_TRUNC, 0755)
	mainLogger := log.New(file, "[main]", log.Ldate|log.Ltime)

	l := make(map[string]*log.Logger)
	l["main"] = mainLogger

	return &ReverseProxy{
		inputNodes: make(map[string]*proxyEntry),
		loggers:    l,
		entryLock:  sync.RWMutex{},
		logLock:    sync.RWMutex{},
	}
}

func (r *ReverseProxy) RegisterEntry(ctx context.Context, req *protocol.RegisterRequest) (*protocol.RegisterResponse, error) {
	address := req.FullAddr

	r.logf("main", "Requested to register %s", address)

	r.entryLock.Lock()
	defer r.entryLock.Unlock()
	if _, ok := r.inputNodes[address]; ok {
		// already present
		r.logf("main", "%s was already present", address)
		return &protocol.RegisterResponse{Success: false}, nil
	}

	r.inputNodes[address] = nil
	r.addLog(address)

	r.logf("main", "Node %s registered. Logfile created", address)
	r.logf(address, "Node registered. Logfile created")

	return &protocol.RegisterResponse{Success: true}, nil
}

func (r *ReverseProxy) DeleteEntry(ctx context.Context, req *protocol.DeleteRequest) (*protocol.DeleteResponse, error) {
	address := req.FullAddr

	r.entryLock.Lock()
	defer r.entryLock.Unlock()
	if _, ok := r.inputNodes[address]; !ok {
		// already present
		return &protocol.DeleteResponse{Success: false}, nil
	}

	delete(r.inputNodes, address)

	return &protocol.DeleteResponse{Success: true}, nil
}

func (r *ReverseProxy) StartRegisterService() {
	lis, err := net.Listen("tcp", ":45998")
	if err != nil {
		r.loggers["main"].Fatalf("%v", err)
	}
	r.logf("main", "Started listening on TCP port 45998")
	grpcServer := grpc.NewServer()
	protocol.RegisterEntryRegistryServer(grpcServer, r)

	r.logf("main", "Awaiting to serve")
	if err := grpcServer.Serve(lis); err != nil {
		r.loggers["main"].Fatalf("%v", err)
	}
}
